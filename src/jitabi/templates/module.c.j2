#define PY_SSIZE_T_CLEAN
#include <Python.h>

#include <stdint.h>
#include <stdbool.h>
#include <string.h>
#include <stdio.h>
#include <limits.h>

// system & compiler checks
#if __BYTE_ORDER__ != __ORDER_LITTLE_ENDIAN__
    #error "little-endian host required"
#endif
#ifndef __SIZEOF_INT128__
    #error "int128 compiler support required"
#endif


#ifdef __JITABI_DEBUG
#include <stdarg.h>
// logging

// Static variables
static PyObject *logger_debug = NULL;
static PyObject *logger_info = NULL;
static PyObject *logger_warning = NULL;
static PyObject *logger_error = NULL;

// Called during PyMODINIT_FUNC (i.e., module init)
static int init_logging_handles(void) {
    PyObject *logging = PyImport_ImportModule("logging");
    if (!logging) return -1;

    PyObject *getLogger = PyObject_GetAttrString(logging, "getLogger");
    if (!getLogger || !PyCallable_Check(getLogger)) {
        Py_XDECREF(getLogger);
        Py_DECREF(logging);
        return -1;
    }

    PyObject *name = PyUnicode_FromString("jitabi.{{ m_name }}");
    PyObject *logger = PyObject_CallOneArg(getLogger, name);
    Py_DECREF(name);
    Py_DECREF(getLogger);
    Py_DECREF(logging);

    if (!logger) return -1;

    #define GET_LMETHOD(var, method) do {                          \
        var = PyObject_GetAttrString(logger, method);              \
        if (!var || !PyCallable_Check(var)) {                      \
            Py_XDECREF(var);                                       \
            Py_DECREF(logger);                                     \
            return -1;                                             \
        }                                                          \
    } while (0)

    GET_LMETHOD(logger_debug, "debug");
    GET_LMETHOD(logger_info, "info");
    GET_LMETHOD(logger_warning, "warning");
    GET_LMETHOD(logger_error, "error");

    #undef GET_LMETHOD
    Py_DECREF(logger);

    // Success
    return 0;
}

static void logger_logf(PyObject *fn, const char *fmt, ...)
{
    if (!fn) return;

    char buf[512];
    va_list args;
    va_start(args, fmt);
    vsnprintf(buf, sizeof(buf), fmt, args);
    va_end(args);

    PyObject *msg = PyUnicode_FromString(buf);
    if (!msg) return;

    PyObject *res = PyObject_CallOneArg(fn, msg);
    Py_XDECREF(res);
    Py_DECREF(msg);
}

#define JITABI_LOG_DEBUG(...) logger_logf(logger_debug,   __VA_ARGS__)
#define JITABI_LOG_INFO(...)  logger_logf(logger_info,    __VA_ARGS__)
#define JITABI_LOG_WARN(...)  logger_logf(logger_warning, __VA_ARGS__)
#define JITABI_LOG_ERROR(...) logger_logf(logger_error,   __VA_ARGS__)

#else

#define JITABI_LOG_DEBUG(...) ((void)0)
#define JITABI_LOG_INFO(...)  ((void)0)
#define JITABI_LOG_WARN(...)  ((void)0)
#define JITABI_LOG_ERROR(...) ((void)0)
#endif


static inline uint16_t read_le16(const char *p)
{
    return *(const uint16_t *)p;
}

static inline uint32_t read_le32(const char *p)
{
    return *(const uint32_t *)p;
}

static inline uint64_t read_le64(const char *p)
{
    return *(const uint64_t *)p;
}

static inline __attribute__((always_inline, hot, pure))
unsigned long long decode_varuint32(const char *restrict p, size_t *consumed)
{
    const unsigned char *s = (const unsigned char *)p;
    unsigned long long r = 0;
    unsigned char b;
    unsigned shift = 0;

    /* first byte (-90 % of the time) */
    b  = *s++;
    r  =  b & 0x7F;
    if (!(b & 0x80)) {
        if (consumed) *consumed = 1;
        return r;
    }
    shift = 7;

    /* remaining bytes (rare) */
    while ( (b = *s++) & 0x80 ) {
        r |= ((unsigned long long)(b & 0x7F)) << shift;
        shift += 7;
    }
    r |= ((unsigned long long)b) << shift;

    if (consumed) *consumed = (size_t)(s - (const unsigned char *)p);
    return r;
}

static inline __attribute__((always_inline, hot, pure))
ssize_t encode_varuint32(unsigned long long val, char *out)
{
    size_t i = 0;
    do {
        unsigned char b = val & 0x7F;
        val >>= 7;
        if (val) b |= 0x80;
        out[i++] = b;
    } while (val);
    return i;
}

static inline __attribute__((always_inline, hot, pure))
long long decode_varint32(const char *restrict p, size_t *consumed)
{
    const unsigned char *s = (const unsigned char *)p;
    long long r = 0;
    unsigned char b;
    unsigned shift = 0;

    /* first byte fast-path */
    b  = *s++;
    r  =  b & 0x7F;
    if (!(b & 0x80)) {
        if (b & 0x40)   /* sign-extend negative single-byte values */
            r |= -1LL << 7;
        if (consumed) *consumed = 1;
        return r;
    }
    shift = 7;

    /* remaining bytes */
    while ( (b = *s++) & 0x80 ) {
        r |= ((long long)(b & 0x7F)) << shift;
        shift += 7;
    }
    r |= ((long long)b & 0x7F) << shift;

    /* final sign-extension if negative */
    if ((b & 0x40) && (shift + 7 < sizeof(long long) * 8))
        r |= -1LL << (shift + 7);

    if (consumed) *consumed = (size_t)(s - (const unsigned char *)p);
    return r;
}

static inline __attribute__((always_inline, hot, pure))
ssize_t encode_varint32(long long val, char *out)
{
    size_t i = 0;
    int more = 1;

    while (more) {
        unsigned char byte = val & 0x7F;
        int sign_bit = (byte & 0x40) != 0;

        val >>= 7;

        // Determine if more bytes are needed
        if ((val == 0 && !sign_bit) || (val == -1 && sign_bit)) {
            more = 0;
        } else {
            byte |= 0x80;
        }

        out[i++] = byte;
    }

    return (ssize_t)i;
}

static inline __attribute__((always_inline, hot, pure))
PyObject *uint128_to_pylong(unsigned __int128 v)
{
    char buf[35];
    snprintf(buf,
             sizeof buf,
             "0x%016llx%016llx",
             (unsigned long long)(v >> 64),
             (unsigned long long)v);
    return PyLong_FromString(buf, NULL, 0);
}

// bool

static inline __attribute__((always_inline, hot, pure))
PyObject *unpack_bool (const char *b, size_t buf_len, size_t *c)
{ if (c) *c = 1;  return PyBool_FromLong(b[0] != 0); }


static inline __attribute__((always_inline, hot, pure))
ssize_t pack_bool(PyObject *obj, char *out, size_t out_len)
{
    int res = PyObject_IsTrue(obj);
    if (res < 0) return -1;
    out[0] = (char)(res ? 1 : 0);
    return 1;
}

// uint8

static inline __attribute__((always_inline, hot, pure)) PyObject *
unpack_uint8 (const char *b, size_t buf_len, size_t *c)
{ if (c) *c = 1;  return PyLong_FromUnsignedLong((unsigned char)b[0]); }

static inline __attribute__((always_inline, hot, pure))
ssize_t pack_uint8(PyObject *obj, char *out, size_t out_len)
{
    unsigned long val = PyLong_AsUnsignedLong(obj);
    if (PyErr_Occurred()) return -1;
    if (val > 0xFF) {
        PyErr_SetString(PyExc_OverflowError, "uint8 out of range");
        return -1;
    }
    out[0] = (unsigned char)val;
    return 1;
}

// uint16

static inline __attribute__((always_inline, hot, pure))
PyObject *unpack_uint16 (const char *b, size_t buf_len, size_t *c)
{ if (c) *c = 2;  return PyLong_FromUnsignedLong(read_le16(b)); }

static inline __attribute__((always_inline, hot, pure))
ssize_t pack_uint16(PyObject *obj, char *out, size_t out_len)
{
    unsigned long val = PyLong_AsUnsignedLong(obj);
    if (PyErr_Occurred()) return -1;
    if (val > 0xFFFF) {
        PyErr_SetString(PyExc_OverflowError, "uint16 out of range");
        return -1;
    }

    uint16_t u16 = (uint16_t)val;
    out[0] = (char)(u16 & 0xFF);
    out[1] = (char)((u16 >> 8) & 0xFF);
    return 2;
}

// uint32

static inline __attribute__((always_inline, hot, pure))
PyObject *unpack_uint32 (const char *b, size_t buf_len, size_t *c)
{ if (c) *c = 4;  return PyLong_FromUnsignedLong(read_le32(b)); }

static inline __attribute__((always_inline, hot, pure))
ssize_t pack_uint32(PyObject *obj, char *out, size_t out_len)
{
    unsigned long val = PyLong_AsUnsignedLong(obj);
    if (PyErr_Occurred()) return -1;

    // On LLP64 platforms like Windows, PyLong_AsUnsignedLong may truncate >32-bit
    if (val > 0xFFFFFFFFUL) {
        PyErr_SetString(PyExc_OverflowError, "uint32 out of range");
        return -1;
    }

    uint32_t u32 = (uint32_t)val;
    out[0] = (char)(u32 & 0xFF);
    out[1] = (char)((u32 >> 8) & 0xFF);
    out[2] = (char)((u32 >> 16) & 0xFF);
    out[3] = (char)((u32 >> 24) & 0xFF);
    return 4;
}

// uint64

static inline __attribute__((always_inline, hot, pure))
PyObject *unpack_uint64 (const char *b, size_t buf_len, size_t *c)
{ if (c) *c = 8;  return PyLong_FromUnsignedLongLong(read_le64(b)); }

static inline __attribute__((always_inline, hot, pure))
ssize_t pack_uint64(PyObject *obj, char *out, size_t out_len)
{
    unsigned long long val = PyLong_AsUnsignedLongLong(obj);
    if (PyErr_Occurred()) return -1;

    uint64_t u64 = (uint64_t)val;
    out[0] = (char)(u64 & 0xFF);
    out[1] = (char)((u64 >> 8) & 0xFF);
    out[2] = (char)((u64 >> 16) & 0xFF);
    out[3] = (char)((u64 >> 24) & 0xFF);
    out[4] = (char)((u64 >> 32) & 0xFF);
    out[5] = (char)((u64 >> 40) & 0xFF);
    out[6] = (char)((u64 >> 48) & 0xFF);
    out[7] = (char)((u64 >> 56) & 0xFF);
    return 8;
}

// uint128

static inline __attribute__((always_inline, hot, pure))
PyObject *unpack_uint128 (const char *b, size_t buf_len, size_t *c)
{
    if (c) *c = 16;
    unsigned __int128 v =
        ((unsigned __int128)read_le64(b + 8) << 64) | read_le64(b);
    return uint128_to_pylong(v);
}

static inline __attribute__((always_inline, hot, pure))
ssize_t pack_uint128(PyObject *obj, char *out, size_t out_len)
{
    if (!PyLong_Check(obj)) {
        PyErr_SetString(PyExc_TypeError, "expected int for uint128");
        return -1;
    }

    // Mask to get low 64 bits
    PyObject *lo_obj = PyNumber_And(obj, PyLong_FromUnsignedLongLong(0xFFFFFFFFFFFFFFFFULL));
    if (!lo_obj) return -1;

    // Shift right to get high 64 bits
    PyObject *hi_obj = PyNumber_Rshift(obj, PyLong_FromLong(64));
    if (!hi_obj) { Py_DECREF(lo_obj); return -1; }

    uint64_t lo = PyLong_AsUnsignedLongLong(lo_obj);
    uint64_t hi = PyLong_AsUnsignedLongLong(hi_obj);

    Py_DECREF(lo_obj);
    Py_DECREF(hi_obj);

    if (PyErr_Occurred()) return -1;

    memcpy(out,     &lo, 8);
    memcpy(out + 8, &hi, 8);
    return 16;
}

// int8

static inline __attribute__((always_inline, hot, pure)) PyObject *
unpack_int8 (const char *b, size_t buf_len, size_t *c)
{ if (c) *c = 1;  return PyLong_FromLong((signed char)b[0]); }

static inline __attribute__((always_inline, hot, pure))
ssize_t pack_int8(PyObject *obj, char *out, size_t out_len)
{
    long val = PyLong_AsLong(obj);
    if (PyErr_Occurred()) return -1;
    if (val < -128 || val > 127) {
        PyErr_SetString(PyExc_OverflowError, "int8 out of range");
        return -1;
    }
    out[0] = (signed char)val;
    return 1;
}

// int16

static inline __attribute__((always_inline, hot, pure))
PyObject *unpack_int16 (const char *b, size_t buf_len, size_t *c)
{ if (c) *c = 2;  return PyLong_FromLong((int16_t)read_le16(b)); }

static inline __attribute__((always_inline, hot, pure))
ssize_t pack_int16(PyObject *obj, char *out, size_t out_len)
{
    long val = PyLong_AsLong(obj);
    if (PyErr_Occurred()) return -1;
    if (val < -32768 || val > 32767) {
        PyErr_SetString(PyExc_OverflowError, "int16 out of range");
        return -1;
    }

    int16_t i16 = (int16_t)val;
    out[0] = (char)(i16 & 0xFF);
    out[1] = (char)((i16 >> 8) & 0xFF);
    return 2;
}

// int32

static inline __attribute__((always_inline, hot, pure))
PyObject *unpack_int32 (const char *b, size_t buf_len, size_t *c)
{ if (c) *c = 4;  return PyLong_FromLong((int32_t)read_le32(b)); }

static inline __attribute__((always_inline, hot, pure))
ssize_t pack_int32(PyObject *obj, char *out, size_t out_len)
{
    long val = PyLong_AsLong(obj);
    if (PyErr_Occurred()) return -1;

    if (val < INT32_MIN || val > INT32_MAX) {
        PyErr_SetString(PyExc_OverflowError, "int32 out of range");
        return -1;
    }

    int32_t i32 = (int32_t)val;
    out[0] = (char)(i32 & 0xFF);
    out[1] = (char)((i32 >> 8) & 0xFF);
    out[2] = (char)((i32 >> 16) & 0xFF);
    out[3] = (char)((i32 >> 24) & 0xFF);
    return 4;
}

// int64

static inline __attribute__((always_inline, hot, pure))
PyObject *unpack_int64 (const char *b, size_t buf_len, size_t *c)
{ if (c) *c = 8;  return PyLong_FromLongLong((int64_t)read_le64(b)); }

static inline __attribute__((always_inline, hot, pure))
ssize_t pack_int64(PyObject *obj, char *out, size_t out_len)
{
    long long val = PyLong_AsLongLong(obj);
    if (PyErr_Occurred()) return -1;

    int64_t i64 = (int64_t)val;
    out[0] = (char)(i64 & 0xFF);
    out[1] = (char)((i64 >> 8) & 0xFF);
    out[2] = (char)((i64 >> 16) & 0xFF);
    out[3] = (char)((i64 >> 24) & 0xFF);
    out[4] = (char)((i64 >> 32) & 0xFF);
    out[5] = (char)((i64 >> 40) & 0xFF);
    out[6] = (char)((i64 >> 48) & 0xFF);
    out[7] = (char)((i64 >> 56) & 0xFF);
    return 8;
}

// int128

static inline __attribute__((always_inline, hot, pure))
PyObject *unpack_int128 (const char *b, size_t buf_len, size_t *c){
    if (c) *c = 16;
    __int128 v; /* signed */
    memcpy(&v, b, 16); /* avoids the &-on-temporary */
    return uint128_to_pylong((unsigned __int128)v); /* quick & dirty -- adjust if you need signed range */
}

static inline __attribute__((always_inline, hot, pure))
ssize_t pack_int128(PyObject *obj, char *out, size_t out_len)
{
    if (!PyLong_Check(obj)) {
        PyErr_SetString(PyExc_TypeError, "expected int for int128");
        return -1;
    }

    // Convert Python int to two's complement 16-byte representation manually
    PyObject *tmp = PyNumber_ToBase(obj, 10);
    if (!tmp) return -1;

    __int128 val = 0;
    int sign = PyObject_RichCompareBool(obj, PyLong_FromLong(0), Py_LT);
    if (sign < 0) return -1;

    PyObject *abs_obj = PyNumber_Absolute(obj);
    if (!abs_obj) return -1;

    uint64_t lo = PyLong_AsUnsignedLongLong(abs_obj);
    PyObject *hi_obj = PyNumber_Rshift(abs_obj, PyLong_FromLong(64));
    uint64_t hi = PyLong_AsUnsignedLongLong(hi_obj);
    Py_DECREF(abs_obj);
    Py_DECREF(hi_obj);

    if (PyErr_Occurred()) return -1;

    val = ((__int128)hi << 64) | lo;

    if (sign) val = -val;

    memcpy(out, &val, 16);
    return 16;
}

// varuint32

static inline __attribute__((always_inline, hot, pure))
PyObject *unpack_varuint32 (const char *b, size_t buf_len, size_t *c)
{
    unsigned long long v = decode_varuint32(b, c);
    return PyLong_FromUnsignedLongLong(v);
}

static inline __attribute__((always_inline, hot, pure))
ssize_t pack_varuint32(PyObject *obj, char *out, size_t out_len)
{
    unsigned long long val = PyLong_AsUnsignedLongLong(obj);
    if (PyErr_Occurred()) return -1;

    return encode_varuint32(val, out);
}

// varint32

static inline __attribute__((always_inline, hot, pure))
PyObject *unpack_varint32 (const char *b, size_t buf_len, size_t *c)
{
    long long v = decode_varint32(b, c);
    return PyLong_FromLongLong(v);
}

static inline __attribute__((always_inline, hot, pure))
ssize_t pack_varint32(PyObject *obj, char *out, size_t out_len)
{
    long long val = PyLong_AsLongLong(obj);
    if (PyErr_Occurred()) return -1;

    return encode_varint32(val, out);
}

// float32

static inline __attribute__((always_inline, hot, pure))
PyObject *unpack_float32 (const char *b, size_t buf_len, size_t *c)
{
    if (c) *c = 4;
    float f;
    memcpy(&f, b, 4);
    return PyFloat_FromDouble((double)f);
}

static inline __attribute__((always_inline, hot, pure))
ssize_t pack_float32(PyObject *obj, char *out, size_t out_len)
{
    float f = (float)PyFloat_AsDouble(obj);
    if (PyErr_Occurred()) return -1;
    memcpy(out, &f, 4);
    return 4;
}

// float64

static inline __attribute__((always_inline, hot, pure))
PyObject *unpack_float64 (const char *b, size_t buf_len, size_t *c)
{
    if (c) *c = 8;
    double d;
    memcpy(&d, b, 8);
    return PyFloat_FromDouble(d);
}

static inline __attribute__((always_inline, hot, pure))
ssize_t pack_float64(PyObject *obj, char *out, size_t out_len)
{
    double d = PyFloat_AsDouble(obj);
    if (PyErr_Occurred()) return -1;
    memcpy(out, &d, 8);
    return 8;
}

// raw

static inline __attribute__((always_inline, hot, pure))
PyObject *unpack_raw (const char *b, size_t len, size_t buf_len, size_t *c)
{
    if (c) *c = len;
    return PyBytes_FromStringAndSize(b, len);
}

static inline __attribute__((always_inline, hot, pure))
ssize_t pack_raw(PyObject *obj, size_t len, char *out, size_t out_len)
{
    if (!PyBytes_Check(obj)) {
        PyErr_SetString(PyExc_TypeError, "expected a bytes object");
        return -1;
    }

    Py_ssize_t size;
    char *data;
    if (PyBytes_AsStringAndSize(obj, &data, &size) < 0)
        return -1;

    if ((size_t)size > out_len) {
        PyErr_SetString(PyExc_ValueError, "output buffer too small for raw data");
        return -1;
    }

    memcpy(out, data, (size_t)size);
    return size;
}

// bytes

static inline __attribute__((always_inline, hot, pure))
PyObject *unpack_bytes (const char *b, size_t buf_len, size_t *c)
{
    size_t len_consumed = 0;
    unsigned long long l = decode_varuint32(b, &len_consumed);

    JITABI_LOG_DEBUG("leb consumed: %lu", len_consumed);
    JITABI_LOG_DEBUG("about to unpack bytes of size: %llu", l);

    if (l > PY_SSIZE_T_MAX ||
        l > (unsigned long long)(buf_len - len_consumed)) {
        PyErr_SetString(PyExc_ValueError, "buffer too small for encoded length");
        return NULL;
    }

    if (c) *c = len_consumed + (size_t)l;
    return PyBytes_FromStringAndSize(b + len_consumed, (Py_ssize_t)l);
}


static inline __attribute__((always_inline, hot, pure))
ssize_t pack_bytes(PyObject *obj, char *out, size_t out_len)
{
    if (!PyBytes_Check(obj)) {
        PyErr_SetString(PyExc_TypeError, "expected a bytes object");
        return -1;
    }

    Py_ssize_t size;
    char *data;
    if (PyBytes_AsStringAndSize(obj, &data, &size) < 0)
        return -1;

    char len_buf[10];
    ssize_t len_len = encode_varuint32((unsigned long long)size, len_buf);

    if ((size_t)(len_len + size) > out_len) {
        PyErr_SetString(PyExc_ValueError, "output buffer too small for bytes");
        return -1;
    }

    memcpy(out, len_buf, (size_t)len_len);
    memcpy(out + len_len, data, (size_t)size);

    return len_len + size;
}

// string

static inline __attribute__((always_inline, hot, pure))
PyObject *unpack_string (const char *b, size_t buf_len, size_t *c)
{
    size_t len_consumed = 0;
    unsigned long long l = decode_varuint32(b, &len_consumed);

    if (l > PY_SSIZE_T_MAX ||
        l > (unsigned long long)(buf_len - len_consumed)) {
        PyErr_SetString(PyExc_ValueError, "buffer too small for encoded length");
        return NULL;
    }

    if (c) *c = len_consumed + (size_t)l;
    return PyUnicode_DecodeUTF8(b + len_consumed, (Py_ssize_t)l, "strict");
}


static inline __attribute__((always_inline, hot, pure))
ssize_t pack_string(PyObject *obj, char *out, size_t out_len)
{
    if (!PyUnicode_Check(obj)) {
        PyErr_SetString(PyExc_TypeError, "expected a string");
        return -1;
    }

    Py_ssize_t size;
    const char *utf8 = PyUnicode_AsUTF8AndSize(obj, &size);
    if (!utf8)
        return -1;

    char len_buf[10];
    ssize_t len_len = encode_varuint32((unsigned long long)size, len_buf);

    if ((size_t)(len_len + size) > out_len) {
        PyErr_SetString(PyExc_ValueError, "output buffer too small for string");
        return -1;
    }

    memcpy(out, len_buf, (size_t)len_len);
    memcpy(out + len_len, utf8, (size_t)size);

    return len_len + size;
}


// forward declarations
{% for f in functions %}
static inline PyObject *unpack_{{ f.name }}(const char *b, size_t buf_len, size_t *c);
static inline ssize_t   pack_{{ f.name }}(PyObject *obj, char *out, size_t out_len);
{% endfor -%}
{% for a in aliases %}
static inline PyObject *unpack_{{ a.alias }}(const char *b, size_t buf_len, size_t *c);
static inline ssize_t   pack_{{ a.alias }}(PyObject *obj, char *out, size_t out_len);
{% endfor -%}

{% for f in functions %}

{{ f.unpack_code }}

{{ f.pack_code }}
{%- endfor -%}
{% for a in aliases %}

{{ a.unpack_code }}

{{ a.pack_code }}
{%- endfor %}


#define DEF_UNPACK_WRAPPER(pyname, cfunc)                                \
    static PyObject *pyname(PyObject *self, PyObject *arg)               \
    {                                                                    \
        if (!PyBytes_Check(arg)) {                                       \
            PyErr_SetString(PyExc_TypeError, "expected a bytes object"); \
            return NULL;                                                 \
        }                                                                \
        Py_ssize_t len;                                                  \
        char *buf;                                                       \
        PyBytes_AsStringAndSize(arg, &buf, &len);                        \
        return cfunc(buf, (size_t)len, NULL);                         \
    }


#define DEF_PACK_WRAPPER(pyname, cfunc, INITIAL)                           \
    static PyObject *pyname(PyObject *self, PyObject *arg)                 \
    {                                                                      \
        Py_ssize_t cap = (INITIAL);                                        \
        PyObject *bytes = PyBytes_FromStringAndSize(NULL, cap);            \
        if (!bytes)                                                        \
            return NULL;                                                   \
                                                                           \
        for (int attempts = 0; attempts < 5; ++attempts) {                 \
            char *buf = PyBytes_AS_STRING(bytes);                          \
            ssize_t written = cfunc(arg, buf, (size_t)cap);             \
                                                                           \
            /* success: shrink to actual size and return */                \
            if (written >= 0) {                                            \
                if (written > cap) { /* impossible if packer is correct */ \
                    Py_DECREF(bytes);                                      \
                    PyErr_SetString(                                       \
                        PyExc_RuntimeError,                                \
                        "packer returned size larger than buffer"          \
                    );                                                     \
                    return NULL;                                           \
                }                                                          \
                /* shrink, ignore fail */                                  \
                _PyBytes_Resize(&bytes, written);                          \
                return bytes;                                              \
            }                                                              \
                                                                           \
            /* failure for any reason *other* than buffer-too-small */     \
            if (!PyErr_ExceptionMatches(PyExc_ValueError)) {               \
                Py_DECREF(bytes);                                          \
                return NULL;                                               \
            }                                                              \
                                                                           \
            /* Look for the specific diagnostic we set in the packer.      \
               You could give your packers a dedicated error subclass      \
               instead, but a string check keeps it light-weight. */       \
            if (!PyErr_Occurred() ||                                       \
                strstr(PyUnicode_AsUTF8(PyObject_Str(PyErr_Occurred())),   \
                       "output buffer too small") == NULL) {               \
                Py_DECREF(bytes);                                          \
                return NULL;                                               \
            }                                                              \
                                                                           \
            /* Clear the ValueError and grow the buffer ×2 */              \
            PyErr_Clear();                                                 \
            cap *= 2;                                                      \
            if (_PyBytes_Resize(&bytes, cap) < 0) {                        \
                Py_DECREF(bytes);                                          \
                return NULL;                                               \
            }                                                              \
        }                                                                  \
                                                                           \
        Py_DECREF(bytes);                                                  \
        PyErr_SetString(PyExc_RuntimeError,                                \
                        "exceeded maximum resize attempts in pack wrapper"); \
        return NULL;                                                       \
    }


// structs & enums
{%- for f in functions %}
DEF_UNPACK_WRAPPER (py_unpack_{{ f.name }}, unpack_{{ f.name }})
DEF_PACK_WRAPPER   (py_pack_{{ f.name }}, pack_{{ f.name }}, 5 * 1024)
{%- endfor %}

// aliases
{%- for a in aliases %}
DEF_UNPACK_WRAPPER (py_unpack_{{ a.alias }}, unpack_{{ a.alias }})
DEF_PACK_WRAPPER   (py_pack_{{ a.alias }}, pack_{{ a.alias }}, 5 * 1024)
{%- endfor %}

// type name dispatch

// unpack
typedef PyObject *(*unpack_fn_t)(const char *, size_t, size_t *);

// pack
typedef ssize_t (*pack_fn_t)(PyObject *, char *, size_t);

struct dispatch_entry {
    const char  *name;
    unpack_fn_t ufn;
    pack_fn_t   pfn;
};

/* table is terminated by {NULL, NULL} for easy iteration */
static const struct dispatch_entry _DISPATCH[] = {
    {"bool",      unpack_bool,    pack_bool},

    {"uint8",     unpack_uint8,   pack_uint8},
    {"uint16",    unpack_uint16,  pack_uint16},
    {"uint32",    unpack_uint32,  pack_uint32},
    {"uint64",    unpack_uint64,  pack_uint64},
    {"uint128",   unpack_uint128, pack_uint128},

    {"int8",      unpack_int8,     pack_int8},
    {"int16",     unpack_int16,    pack_int16},
    {"int32",     unpack_int32,    pack_int32},
    {"int64",     unpack_int64,    pack_int64},
    {"int128",    unpack_int128,   pack_int128},

    {"varuint32", unpack_varuint32, pack_varuint32},
    {"varint32",  unpack_varint32,  pack_varint32},

    {"float32",   unpack_float32, pack_float32},
    {"float64",   unpack_float64, pack_float64},

    {"bytes",     unpack_bytes,   pack_bytes},
    {"str",       unpack_string,  pack_string},

{%- for f in functions %}
    {"{{ f.name }}", unpack_{{ f.name }}, pack_{{ f.name }}},
{%- endfor %}
{%- for a in aliases %}
    {"{{ a.alias }}", unpack_{{ a.alias }}, pack_{{ a.alias }}},
{%- endfor %}
    { NULL, NULL }
};

static PyObject *
py_unpack(PyObject *self, PyObject *const *args, Py_ssize_t nargs)
{
    if (!PyUnicode_Check(args[0])) {
        PyErr_SetString(PyExc_TypeError, "expected a bytes object");
        return NULL;
    }
    Py_ssize_t tn_len;
    const char *type_name = PyUnicode_AsUTF8AndSize(args[0], &tn_len);

    if (!PyBytes_Check(args[1])) {
        PyErr_SetString(PyExc_TypeError, "expected a bytes object");
        return NULL;
    }
    Py_ssize_t buf_len;
    char *buf;
    PyBytes_AsStringAndSize(args[1], &buf, &buf_len);

    // check type name for modifiers
    bool is_array = tn_len >= 2 &&
                    type_name[tn_len - 1] == ']' &&
                    type_name[tn_len - 2] == '[';

    const char *base = type_name;
    char local_buf[256];  // only used when we need to strip modifiers
    if (is_array) {
        memcpy(local_buf, type_name, tn_len - 2);
        local_buf[tn_len - 2] = '\0';
        base = local_buf;
    }

    // locate the base-type’s unpack function
    unpack_fn_t fn = NULL;
    for (const struct dispatch_entry *it = _DISPATCH; it->name; ++it)
        if (strcmp(base, it->name) == 0) {
            fn = it->ufn;
            break;
        }

    if (!fn) {
        PyErr_Format(PyExc_ValueError,
                     "unknown type '%s'", type_name);
        return NULL;
    }

    // no modifiers, just delegate
    if (!is_array) {
        size_t consumed = 0;
        return fn(buf, (size_t)buf_len, &consumed);
    }

    // array path
    size_t arr_varint_len = 0;
    unsigned long long arr_len = decode_varuint32(buf, &arr_varint_len);
    if (arr_len < 0) {
        PyErr_SetString(PyExc_ValueError, "buffer too short for ULEB128 length");
        return NULL;
    }

    size_t offset = arr_varint_len;

    PyObject *list = PyList_New((Py_ssize_t)arr_len);
    if (!list)
        return NULL;

    for (uint64_t i = 0; i < arr_len; i++) {
        size_t consumed = 0;
        PyObject *item = fn(buf + offset, buf_len - offset, &consumed);
        offset += consumed;
        if (!item) {  // fn should of already set an exception
            Py_DECREF(list);
            return NULL;
        }

        if (PyList_SetItem(list, (Py_ssize_t)i, item) < 0) {  // steal ref
            PyErr_SetString(PyExc_ValueError, "could not set item on list");
            Py_DECREF(item);
            Py_DECREF(list);
            return NULL;
        }

        #ifdef __JITABI_DEBUG
        if (offset > (size_t)buf_len) {
            Py_DECREF(list);
            PyErr_SetString(PyExc_ValueError, "buffer ended mid-array");
            return NULL;
        }
        #endif
    }

    return list;
}

static PyMethodDef Methods[] = {
    // dynamic dispatch
    {
        "unpack",
        (PyCFunction)py_unpack,
        METH_FASTCALL,
        "dispatch-to-type unpack(bytes) helper"
    },

    // structs & enums
    {%- for f in functions %}
    {"unpack_{{ f.name }}", py_unpack_{{ f.name }}, METH_O, "unpack structure {{ f.name }}"},
    {"pack_{{ f.name }}",   py_pack_{{ f.name }},   METH_O, "pack structure {{ f.name }}"},
    {%- endfor %}

    // aliases
    {%- for a in aliases %}
    {"unpack_{{ a.alias }}", py_unpack_{{ a.alias }}, METH_O, "unpack alias {{ a.alias }}"},
    {"pack_{{ a.alias }}",   py_pack_{{ a.alias }},   METH_O, "pack alias {{ a.alias }}"},
    {%- endfor %}

    // sentinel
    {NULL, NULL, 0, NULL}
};

static struct PyModuleDef module_def = {
    PyModuleDef_HEAD_INIT,
    "{{ m_name }}",
    "{{ m_doc }}",
    -1,
    Methods,
};

PyMODINIT_FUNC
PyInit_{{ m_name }}(void)
{
#ifdef __JITABI_DEBUG
    if (init_logging_handles() < 0) return NULL;
#endif
    return PyModule_Create(&module_def);
}
